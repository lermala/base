---
title: Правила работы с git-репозиторием
weight: 30
---

## Общая информация
- Основная ветка - `master`.
- От основной ветки есть ветки разработчиков. При создании своей ветки
  **нужно опираться на порядок нейминга** (см. ниже).
- Если необходимо выкатить доработки на прод, то создается доп. 
ветка-копия текущих разработок. Нейминг: `prod230222`

## 1. Отдельная задача - отдельная ветка
Под каждую задачу создаем отдельную ветку. В наименовании ветки указываем номер задачи из Битрикс24:

```
[Первая_буква_имени + Фамилия]_[номер_задачи]
```
Пример: `vk_12345`

## 2. Каждый коммит именуется по правилам
Порядок названия коммита:

```
#<номер_задачи> (<тип_коммита>) <краткое_описание>
```
Пример: 

```
#30754 (fix) В списке поручений добавила группировку в таблицу
```

- номер задачи - это номер задачи из Битрикс24
- тип коммита - фикс (fix) /фича (feat) /документация (docs) и т. д. Полный список см. ниже.

### Типы коммитов
-	`feat` — используется при добавлении новой функциональности
-	`fix` — если исправили какую-то серьезную багу или забыли добавить какие-то файлы в предыдущий коммит
-	`style` — исправляем опечатки, исправляем форматирование
-	`loc` – изменение локализации
-	`docs` — всё, что касается документации
-	`refactor` — рефакторинг кода приложения
-	`test` — всё, что связано с тестированием


### Больше примеров:
```
#1231 (fix) Исправлена видимость кнопки «Принять»
#1232 (feat) Добавлена сущность ОГ
#1233 (loc) Исправлен medoService.governmentSecName на "СЭВ.Администрация"
#1234 (style) Переименование MunicipalServise на MunicipalService
#1235 (loc) Переименование справочника «Способ отправки» на «Вид доставки»
#1236 (refactor) Удалены неиспользуемые функции, комментарии
```

## 3. В каждый коммит добавляем описание
Из описания коммита должно быть понятно, что было сделано. Формула составления описания для коммита:

`Что сделал` + `для какой сущности` + `подробности (опционально)`

> **Примечание**. Используем русский язык для описания.

### Примеры
- #30701 (fix) Автоматическое заполнение процессных ролей.
  Если в шаблоне МПА добавлен процесс, то при отправке на согласование МПА, созданного по этому шаблону, автоматически не заполнятся процессные роли (Инициатор, Подготовивший, Утверждающий).
- #30705 (fix) В истории изменений не отображалось удаление участников рассылки.
  #30750 (ref) Рефакторинг опубликовании МПА
- #30702 (fix) Роль "Редактор МПА" должна позволять удалять вложения.
  #30750 (fix) При опубликовании на сайт не прикрепляются файлы. Новые МПА в папках не выделяются жирным.
- #24407 (fix) Списки МУ. Скрыла поле "Исполнители", оставила поле "Исполнитель"
- #30712 (feat) Провести настройку формы почтового приглашения на совещание

## 4. Осознанный push
Каждому разрабу работать в локальной базе и 
использовать актуальный дамп.
При изменении модели данных следить за SQL скриптами, 
т. к. IntelliJ IDEA может наделать лишних скриптов.
push делать осознанно!

### Перед командой `push` стоит проверить:
1. [x] Скрипты лежат в соответствующей папке `текущий год/текущий месяц`.
1. [x] Я воспользовался сочетанием `Ctrl` + `Shift` + `L` (убрал лишние библиотеки, проверил стиль написания кода).
1. [x] Назвал ветку по правилам.
1. [x] Каждый мой коммит информативен и соответствует правилам нейминга.
1. [x] В моем коде не присутствует лишних действий и переменных.
1. [x] Если работал с транзакциями, то транзакцию завершил.
1. [x] Если работал с ресурсами (папки действий, отчеты, процессы), то вложил файл в проект и отписал в коммит про JMIX.

### Если есть изменения в модели данных:
1. [x] Скрипты для БД включены в ветку.
2. [x] Скрипты не содержат в себе ничего лишнего и лежат в папке текущего месяца (например папка 05).

### Если работал с атрибутами карточки\views:
1. [x] Я сделал проверку на null для каждого атрибута.
#### Если есть расширение Холдинга:
1. [x] Я переопределял бины, экраны и т. д. от ХОЛДИНГА, а не штатные тезисовские.

## 5. Порядок слияния merge
Для слияния веток используются команды:
- `cherry-pick` - удобно, если нужно слить немного коммитов.
- `git merge --squash` - подойдет, если нужно объединить все изменения одной ветки в один коммит.
  
### Почему именно эти команды, а не классический `merge`?
Я пробовала и классический `merge`, и `rebase`, но после этого проект
приходил в хаос. Особенно, если вторая ветка давно не обновлялась.

Плюсы, которые я открыла при ведении таким образом:
+ Управляемость. Команда `merge` сливает все коммиты из второй ветки в `master`, а это
лишняя информация. `cherry-pick` и `git merge --squash` позволяют легко управлять
изменениями.
+ Простота. Нет ничего проще, чем сделать `cherry-pick` нужных коммитов.
Для красоты можно объединить их при помощи `rebase`.
+ Прозрачная история. В этом случае сохраняется линейная структура коммитов.
+ Проще делать код-ревью и убирать ненужное в коммите.