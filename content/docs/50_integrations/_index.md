---
title: Интеграции и API
weight: 50
draft: true
---

## Введение

Что почитать:
- Разница между REST и SOAP: [Хабр / Различия REST и SOAP](https://habr.com/ru/articles/483204)
- Вебхуки и API [Вебхуки: как получать данные без промедления и опросов API](https://proglib.io/p/vebhuki-kak-poluchat-dannye-bez-promedleniya-i-oprosov-api-2019-11-09)
- Статья [Документация по веб-API ASP.NET Core с использованием Swagger (OpenAPI)](https://learn.microsoft.com/ru-ru/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-5.0)
- Как посмотреть параметры запроса в панели разработчика [Как анализировать POST запросы в веб-браузере](https://hackware.ru/?p=8973)
- [Коды ответов HTTP](https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP)
- Статья [Как пользоваться Postman](https://telegra.ph/Kak-polzovatsya-programmoj-Postman-11-01)

Знать
- [ ] Виды интеграций информационных систем (API, шина данных - ESB/MOM/MQ, общая база данных, файловый обмен). Их описание, преимущества и недостатки разных способов, что когда используется.
- [ ] Pull-модель (первоначальный запрос производится клиентом) и push-модель (данные поступают от поставщика к пользователю на основе установленных контрактов).
- [ ] Синхронное, асинхронное и реактивное взаимодействие.
- [ ] Концепции stateful и stateless (с сохранением и без сохранения состояния на стороне сервера).
- [ ] Основы синтаксиса JSON и XML.
- [ ] Типы API (REST, SOAP, JSON:API, GraphQL, RPC, API нативных библиотек), их общее описание.
- [ ] Веб-сервисы. Webhook.
- [x] Протокол HTTP

## Что такое интеграция

**Интеграция** — процесс взаимодействия независимых приложений/микросервисов. Основная цель интеграции - обеспечить обмен информацией между приложениями.

## Виды интеграций

Виды интеграций информационных систем (API, шина данных - ESB/MOM/MQ, общая база данных, файловый обмен). Их описание, преимущества и недостатки разных способов, что когда используется.


Основные технологии и методы интеграции
Шина данных (ESB), API, микросервисы
ESB (Enterprise Service Bus): Позволяет централизованно управлять взаимодействием между системами, масштабируем и удобен для крупных интеграций.
API: Универсальный способ быстрого обмена данными в реальном времени, подходит для интеграций с современными веб-сервисами.
Микросервисы: Разделение функциональности на независимые сервисы, которые легко комбинировать, масштабировать и обновлять.
Стандарты и протоколы интеграции (REST, SOAP, EDI и др.)
REST API: Широко используется для интеграции через интернет, прост в использовании, подходит для большинства веб-приложений.
SOAP: Более строгий стандарт обмена, обычно применяется, когда важна безопасность и надежность передачи данных.
EDI: Используется в электронной коммерции для стандартизированного обмена документами между компаниями.

Кратко:

| Критерий          | Основные виды                                        |
| ----------------- | ---------------------------------------------------- |
| **Архитектура**   | Point-to-Point, ESB, SOA, Microservices, API Gateway |
| **Обмен данными** | Файлы, БД, API, Очереди, События                     |
| **Режим работы**  | Синхронный, Асинхронный, Пакетный, Потоковый         |
| **Уровень**       | Интерфейсный, Прикладной, Данных, Сообщений          |
| **Тип связи**     | Внутренняя, Внешняя, B2B                             |

### По уровню связности (архитектурный подход)

| Вид интеграции                                      | Краткое описание                                                                                                    | Пример                                     |
| --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- | ------------------------------------------ |
| **Точечная (Point-to-Point)**                       | Каждая система напрямую связана с другой. Просто, но плохо масштабируется.                                          | CRM ↔ ERP ↔ Склад                          |
| **Шинная (ESB — Enterprise Service Bus)**           | Все системы подключены через общую **интеграционную шину**, которая управляет сообщениями и преобразованием данных. | 1С ↔ ESB ↔ CRM ↔ BI                        |
| **Сервисная (SOA — Service-Oriented Architecture)** | Системы предоставляют **сервисы (API)**, которыми пользуются другие системы.                                        | REST API, SOAP, gRPC                       |
| **Микросервисная интеграция**                       | Каждая функция — отдельный микросервис, взаимодействие через **API, брокеры сообщений, события**.                   | Kafka, RabbitMQ, REST между микросервисами |
| **Интеграция через API-шлюз**                       | Все внешние вызовы проходят через единый API Gateway, который управляет безопасностью и маршрутизацией.             | API Gateway ↔ микросервисы                 |

### По способу обмена данными

| Способ                                      | Особенности                                                                 | Примеры технологий           |
| ------------------------------------------- | --------------------------------------------------------------------------- | ---------------------------- |
| **Файловая интеграция**                     | Обмен файлами (CSV, XML, JSON) через общие каталоги, FTP или облако.        | CSV, XML, SFTP, Google Drive |
| **Интеграция через БД**                     | Системы обращаются напрямую к базе данных друг друга. Опасно, но быстро.    | SQL-запросы между системами  |
| **Интеграция через API**                    | Системы взаимодействуют через программные интерфейсы (REST, SOAP, GraphQL). | REST API, JSON, HTTP         |
| **Интеграция через очередь сообщений**      | Передача данных через посредника — брокера сообщений. Асинхронно, надёжно.  | RabbitMQ, Kafka, JMS         |
| **Интеграция через события (Event-driven)** | Одна система публикует событие (“создан заказ”), другие подписываются.      | Kafka, AWS SNS/SQS, Webhooks |
| **Интеграция через шину данных (Data Bus)** | Централизованный поток данных, доступный всем системам.                     | ESB, Apache Camel, MuleSoft  |


### По режиму взаимодействия

| Тип взаимодействия         | Описание                                                      | Пример                                  |
| -------------------------- | ------------------------------------------------------------- | --------------------------------------- |
| **Синхронная интеграция**  | Системы ждут ответа сразу — “в реальном времени”.             | REST API: CRM запрашивает данные из ERP |
| **Асинхронная интеграция** | Системы не ждут ответа; обмен идёт через очередь или события. | Отправка сообщения в Kafka или RabbitMQ |
| **Пакетная (Batch)**       | Данные передаются большими порциями по расписанию.            | Ночной импорт данных в хранилище        |
| **Потоковая (Streaming)**  | Передача данных непрерывно, в реальном времени.               | Kafka, Spark Streaming, WebSocket       |


### По типу взаимодействующих систем

| Категория                        | Пример интеграции                                |
| -------------------------------- | ------------------------------------------------ |
| **Система ↔ Система**            | ERP ↔ CRM, бухгалтерия ↔ склад                   |
| **Система ↔ Веб-сервис**         | 1С ↔ REST API маркетплейса                       |
| **Приложение ↔ База данных**     | Мобильное приложение ↔ PostgreSQL                |
| **Внутренняя ↔ Внешняя система** | Внутренний сервис ↔ банковское API               |
| **B2B-интеграция**               | Интеграция между компаниями (EDI, API партнёров) |


### По технологическому уровню

| Уровень                      | Описание                                                      | Пример                      |
| ---------------------------- | ------------------------------------------------------------- | --------------------------- |
| **Интерфейсный**             | Взаимодействие через пользовательский интерфейс (роботы, RPA) | UiPath, Automation Anywhere |
| **Прикладной**               | Через API, SDK, web-сервисы                                   | REST, SOAP, GraphQL         |
| **Данных**                   | Через базы данных, ETL, DWH                                   | SQL, Talend, Pentaho        |
| **Сообщений / событий**      | Через очереди или брокеры                                     | Kafka, RabbitMQ             |
| **Интеграционные платформы** | Через ESB, iPaaS (Integration Platform as a Service)          | MuleSoft, Boomi, WSO2       |



## Интеграционные форматы
Онлайн конвертеры:
- [XML -> XSD](https://www.liquid-technologies.com/online-xml-to-xsd-converter) и [XSD -> XML](https://www.liquid-technologies.com/online-xsd-to-xml-converter)
- [JSON -> JSON Schema](https://www.liquid-technologies.com/online-json-to-schema-converter) и [JSON Schema -> JSON](https://www.liquid-technologies.com/online-schema-to-json-converter)

### JSON + JSON Schema

```json
{
    "user": {
        "id": 12345,
        "name": "Иван Петров",
        "email": "ivan.petrov@example.com",
        "isActive": true,
        "createTs": "2025-10-19T22:15:00Z",
        "hobbies": [
            "чтение",
            "рисование"
        ],
        "accounts": [
            {
                "type": "savings",
                "balance": 12500.75,
                "currency": "RUB"
            },
            {
                "type": "credit",
                "balance": -3400.50,
                "currency": "RUB"
            }
        ]
    }
}
```

```json
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "type": "object",
    "properties": {
        "user": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "isActive": {
                    "type": "boolean"
                },
                "createTs": {
                    "type": "string"
                },
                "hobbies": {
                    "type": "array",
                    "items": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "string"
                        }
                    ]
                },
                "accounts": {
                    "type": "array",
                    "items": [
                        {
                            "type": "object",
                            "properties": {
                                "type": {
                                    "type": "string"
                                },
                                "balance": {
                                    "type": "number"
                                },
                                "currency": {
                                    "type": "string"
                                }
                            },
                            "required": [
                                "type",
                                "balance",
                                "currency"
                            ]
                        },
                        {
                            "type": "object",
                            "properties": {
                                "type": {
                                    "type": "string"
                                },
                                "balance": {
                                    "type": "number"
                                },
                                "currency": {
                                    "type": "string"
                                }
                            },
                            "required": [
                                "type",
                                "balance",
                                "currency"
                            ]
                        }
                    ]
                }
            },
            "required": [
                "id",
                "name",
                "email",
                "isActive",
                "createTs",
                "hobbies",
                "accounts"
            ]
        }
    },
    "required": [
        "user"
    ]
}
```

### XML + XSD
[Что такое XML](https://habr.com/ru/articles/524288)

Из чего состоит XSD?
Основные объекты, из которых состоит XSD-схема:
- элементы (зелёный цвет);
- типы (синий);
- индикаторы порядка (красный).

```xml
<user>
    <id>12345</id>
    <name>Иван Петров</name>
    <email>ivan.petrov@example.com</email>
    <isActive>true</isActive>
    <createTs>2025-10-19T22:15:00Z</createTs>

    <hobbies>
        <hobby>чтение</hobby>
        <hobby>рисование</hobby>
    </hobbies>

    <accounts>
        <account type="savings" currency="RUB">
            <balance>12500.75</balance>
        </account>
        <account type="credit" currency="RUB">
            <balance>-3400.50</balance>
        </account>
    </accounts>
</user>
```

```xsd
<?xml version="1.0" encoding="utf-8"?>
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="user">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="id" type="xs:unsignedShort" />
        <xs:element name="name" type="xs:string" />
        <xs:element name="email" type="xs:string" />
        <xs:element name="isActive" type="xs:boolean" />
        <xs:element name="createTs" type="xs:dateTime" />
        <xs:element name="hobbies">
          <xs:complexType>
            <xs:sequence>
              <xs:element maxOccurs="unbounded" name="hobby" type="xs:string" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="accounts">
          <xs:complexType>
            <xs:sequence>
              <xs:element maxOccurs="unbounded" name="account">
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="balance" type="xs:decimal" />
                  </xs:sequence>
                  <xs:attribute name="type" type="xs:string" use="required" />
                  <xs:attribute name="currency" type="xs:string" use="required" />
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>
```

## Синхронная и асинхронная интеграция

Взаимодействия между системами бывают:
- синхронные (например: REST API, SOAP, gRPC);
- асинхронные (например: Kafka, RabbitMQ, WebSocket)

Различия их в том, что приложения с асинхронным взаимодействием не ждут ответа после отправки запроса, а могут продолжить выполнять свой основной поток задач.

Схема взаимодействия
![alt text](image.png)

### Пагинация
Что почитать:
- [Оптимизация работы с REST API: когда и как использовать пагинацию](https://selectel.ru/blog/pagination)
- [Реализация REST API-метода с пагинацией на примере JSON-Schema и OpenAPI / Habr/ nick_oldman](https://habr.com/ru/amp/publications/846130)

## Вопросы и ответы
56.   Что такое XSD?
57.   Что содержится в XML?
58.   Чем sequence отличается от choice в XSD?
59.   Приходилось ли вам писать XSD?
60.   Что такое пространство имен в XML?
61.   Какими программами вы работали с XML?
62.   Что такое WSDL?
63.   Чем SOAP отличается от REST?
64.   Из чего состоит сообщение в SOAP?
65.   Что содержит HEADER в ответе REST?
66.   Чем отличается ошибка 200 от 201?
67.   Какие методы REST вы знаете?
68.   Чем POST отличается от GET?
69.   Чем PUT отличается от PATCH?
70.   Приходилось ли вам писать JSON? С помощью чего вы писали JSON?
71.   Напишите пример rest-API для книжной библиотеки (напишите методы, эндпоинты и пример JSON).
72.   Что содержит URL в REST запросе?
73.   Как проверить, что сообщение брокера получено в полном объеме?
74.   Знаете ли вы CAP-теорему?
75.   Что такое stateless и stateful, если говорить про сервисы? Rest – это какие сервисы? Что значит stateless сервисы?
76.   Что такое идемпотентность? Почем это важно?
77.   DELETE – идемпотентный метод?
78.   Приходилось ли вам проектировать взаимодействие информационных систем?
79.   Что такое корпоративная шина? Приходилось ли работать с корпоративной шиной?
80.   Чем корпоративная шина отличается от ETL – инструмента?
81.   Чем брокер сообщений отличается от корпоративной шины?
82.   К корпоративной шине подключены веб-сервисы. В одном веб-сервисе появились два новых обязательных поля. Что изменится в интеграции?
83.   Есть некий UI, нужно написать к нему веб-сервис. Опишите вашу постановку – что в ней будет.
84.   Что такое синхронные и асинхронные вызовы?
85.   Приходилось ли вам работать с брокерами сообщений?
86.   Для чего вы использовали брокер сообщений?
87.   Как брокер сообщений гарантирует доставку сообщений?
88.   Чем Kafka отличается от RabbitMQ?
89.   Есть две системы. Назовите все способы интеграции этих систем.
90.   Какие виды/способы интеграции вы знаете?
91.   Клиент читает в Kafka два последних сообщения. Как тому же клиенту заново
прочитать эти два последние сообщения?
92.   Приходилось ли вам проектировать API в нотации OpenAPI/Swagger?
93.   Опишите все способы снизить нагрузку на вебсервис.
94.   Есть четыре системы, участвующие в последовательном исполнении заказа клиента на выдачу карты: форма заявки на выдачу карты, скоринг, печать карты, логистика. Опишите, как вы их интегрируете между собой.
95.   Знакомы ли вы с микросервисами?
96.   Что такое Хореография и Оркестрация?
97.   Какие достоинства и недостатки микросервисов вы знаете?
98.   Расскажите про токен-авторизацию в микросервисах.

## SOAP vs REST

Чем SOAP отличается от REST?

- **SOAP** (Simple Object Access Protocol) - Протокол обмена сообщениями на основе XML. Имеет строгие стандарты: структура, формат, описание, ошибки — всё формализовано.
- **REST** (Representational State Transfer) - Архитектурный стиль, основанный на HTTP-принципах и ресурсо-ориентированном подходе. Использует стандартные HTTP-методы: GET, POST, PUT, DELETE и т. д.

|                        | SOAP                                                             | REST                                             |
| :--------------------- | :--------------------------------------------------------------- | :----------------------------------------------- |
| Основной протокол      | Может работать через HTTP, SMTP и др.                            | Обычно только HTTP                               |
| Идентификация ресурсов | Через операции (методы в WSDL)                                   | Через URL-ресурсы                                |
| Описание интерфейса    | WSDL (Web Service Definition Language) — формальный XML-контракт | OpenAPI / Swagger (JSON/YAML-документ)           |
| Структура сообщений    | Строгое тело `<Envelope>`, `<Header>`, `<Body>`                  | Гибкая структура: URL + заголовки + тело запроса |



Пример REST-запроса:

```
GET https://api.bank.ru/accounts/12345/balance
Accept: application/json
```

Пример SOAP-запроса:
```xml
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:bank="http://example.com/bank">
   <soapenv:Header/>
   <soapenv:Body>
      <bank:GetAccountBalance>
         <bank:AccountID>12345</bank:AccountID>
      </bank:GetAccountBalance>
   </soapenv:Body>
</soapenv:Envelope>
```

### WSDL

**WSDL** (Web Services Description Language) — это язык описания веб-сервисов, основанный на XML.
Он используется, чтобы формально описать, как обращаться к SOAP-сервису:
какие у него методы, какие данные принимает и возвращает, и где он доступен.

WSDL-файл обычно выглядит как XML-документ, в котором есть несколько ключевых разделов:
| Раздел       | Что описывает                                       | Пример                                                                   |
| :----------- | :-------------------------------------------------- | :----------------------------------------------------------------------- |
| `<types>`    | Форматы данных (типизация XML, структура сообщений) | Например, `AccountID` — строка, `Balance` — число                        |
| `<message>`  | Входные и выходные сообщения                        | `GetAccountBalanceRequest` и `GetAccountBalanceResponse`                 |
| `<portType>` | Операции сервиса — как “методы” API                 | `GetAccountBalance`, `TransferFunds`                                     |
| `<binding>`  | Технические детали передачи: протокол, формат SOAP  | Указывает, что используется `SOAP 1.2` по HTTP                           |
| `<service>`  | Адрес сервиса (endpoint)                            | URL, куда отправлять запрос, например `https://api.bank.ru/soap/account` |


Пример упрощённого WSDL

```xml
<definitions name="AccountService"
             xmlns="http://schemas.xmlsoap.org/wsdl/"
             xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
             targetNamespace="http://example.com/bank">

  <message name="GetAccountBalanceRequest">
    <part name="accountId" type="xsd:string"/>
  </message>

  <message name="GetAccountBalanceResponse">
    <part name="balance" type="xsd:decimal"/>
  </message>

  <portType name="AccountServicePortType">
    <operation name="GetAccountBalance">
      <input message="tns:GetAccountBalanceRequest"/>
      <output message="tns:GetAccountBalanceResponse"/>
    </operation>
  </portType>

  <binding name="AccountServiceBinding" type="tns:AccountServicePortType">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
    <operation name="GetAccountBalance">
      <soap:operation soapAction="getBalance"/>
    </operation>
  </binding>

  <service name="AccountService">
    <port name="AccountServicePort" binding="tns:AccountServiceBinding">
      <soap:address location="https://api.bank.ru/soap/account"/>
    </port>
  </service>
</definitions>
```

Как это работает
1. **Клиент получает WSDL-файл** (например, https://api.bank.ru/soap/account?wsdl).
2. Инструмент (или разработчик) читает WSDL и понимает:
   - какие операции доступны;
   - какие параметры нужны;
   - где находится endpoint;
   - какой формат запроса/ответа.
3. Клиент **автоматически генерирует код** для вызова сервиса (например, с помощью wsimport, SoapUI, Postman, Java Axis, и т. д.).



## Идемпотентность

**Идемпотентная** операция — это операция, которая при многократном вызове возвращает один и тот же результат.

https://developer.mozilla.org/ru/docs/Glossary/Idempotent

Идемпотентность в HTTP: `GET` `DELETE` `HEAD`, (delete хоть и возвращает разные коды при повторном вызове, но является идемпотентным)
Неидемпотентные: `POST`


По умолчанию некоторые операции в API не являются идемпотентными. Например, операции, которые изменяют состояние ресурсов. Для обеспечения их идемпотентности, в запросах необходимо передавать заголовок Idempotency-Key (или поле operationId в теле). В заголовке следует указать UUID-строку — ее необходимо сформировать самостоятельно. У каждой операции должен быть свой UUID.

```
Idempotency-Key: <UUID>
```

Когда сервис получит запрос с заголовком Idempotency-Key, он проверит, была ли ранее создана операция с таким UUID. Если операция была создана, сервер вернет объект Operation с текущим статусом этой операции. Если операции с таким UUID не найдено, сервис начнет ее выполнение.

Пример:
```
POST /compute/v1/instances/e0m97h0gbq0foeuis03:start
HTTP/1.1
Host: compute.api.cloud.yandex.net
Idempotency-Key: c1700de3-b8cb-4d8a-9990-e4ebf052e9aa
```


## Монолитная и микросервисная архитектура
Монолитная архитектура - подход, при котором все компоненты приложения тесно связаны и работают как единое целое.

Микросервисная архитектура (MSA - Micro Service Architecture) предполагает полную *автономность* каждого компонента.

![alt text](image-1.png)


|                    |                                                 **Монолит**                                                |                                                                   **Микросервисная**                                                                  |
|:------------------:|:----------------------------------------------------------------------------------------------------------:|:-----------------------------------------------------------------------------------------------------------------------------------------------------:|
| Принцип построения | Одно большое приложение, все компоненты связаны напрямую.                                                  | Приложение разделено на независимые микросервисы. Каждый микросервис - отдельная бизнес-функция.                                                      |
| Разработка         | Одна база кода, простой процесс разработки и развертывания.                                                | Каждый сервис - отдельный репозиторий со своей БД.                                                                                                      |
| Откат разработки   | При небходимости отката откатывается все приложение, включая и рабочие фичи тоже.                          | Откатить можно только не работающий сервис, остальные остаются.                                                                                       |
| Поддержка          | Проще поддерживать, т. к. архитектура простая и не нужно дополнительно разбирать связи с др. компонентами. | При появлении ошибки нужно сначала понять, в каком из микросервисов она появилась. Также добавляется доп. коммуникация между командами микросервисов. |
| Производительность | При перегрузке в определенной функции приложения может пострадать скорость всего приложения.               | Каждый сервис можно размещать на отдельном сервере, проще (и дешевле) распределить нагрузку.                                                          |
| Гибкость           | Привязка к определенному набору технологий. Новые функции могут повлиять на все приложение.                | Для каждого сервиса можно подобрать более подходящую технологию. Можно добавлять новые функции не изменяя все приложение.                             |


Подробнее можно почитать тут:
- [Просто о микросервисах](https://habr.com/ru/companies/raiffeisenbank/articles/346380)
- На основе [Java Microservices: The Basics](https://www.marcobehler.com/guides/java-microservices-a-practical-guide#_java_microservices_the_basics) и его [перевода](https://javarush.com/groups/posts/2660-rukovodstvo-po-mikroservisam-java-chastjh-1-osnovih-mikroservisov-i-ikh-arkhitektura)
- Об архитектуре ПО и других видах ИТ-архитектур [От монолита до микросервисов: как устроена архитектура ПО](https://blog.skillfactory.ru/ot-monolita-do-mikroservisov-kak-ustroena-arhitektura-po)
- [Монолит или микросервисы: какую архитектуру выбрать для нового проекта](https://tproger.ru/articles/monolit-ili-mikroservisy--kak-vybrat-arhitekturu-dlya-novogo-proekta)
- [Microservice Architecture Microservices.io](https://microservices.io/index.html)

### Монолит

Минусы:
- Может быть нагрузка
- При откате неработающей функции работающие функции придется откатить тоже.
- Привязка к определенному набору технологий. Новые функции могут повлиять на все приложение.

Плюсы:
- Одна база кода, простой процесс разработки и развертывания.
- Простая архитектура. При разработке акцент на функциональность, а не на взаимодействие компонентов.
- На старте скорость разработки будет выше, яем у микросервисов. Но с ростом функционала монолита скорость будет снижаться.
- Дебаг проще

### Микросервисная архитектура
Микросервисная архитектура может подойти для крупных проектов для упрощения разработки и повышения производительности+отказоустойчивости. Основной принцип такой архитектуры заключается в независимости микросервисом друг от друга. Иными словами - каждый микросервис можно разрабатывать, тестировать, деплоить (и откатывать) независимо друг от друга. Один микросервис - это одна бизнес-функция, что позволяет не размывать границы микросервиса.

Плюсы:
- Гибкая и удобная разработка. Каждый микросервис - это отдельная бизнес-функция.
- Распределение нагрузки, масштабирование проще (и дешевле).
- Изолированность микросервисов. Проще разделять технологии для микросервисов, упрощенный деплой.
- При работе с микросервиса необязательно знать, как работают остальные сервисы (в отличие от монолита).
- Для каждого сервиса можно подобрать более подходящую технологию. Можно добавлять новые функции не изменяя все приложение.

Минусы:
- Сложная архитектура, т. к. нужно продумать взаимодействие сервисов. Сложнее в администрировании, мониторинге, поддержке.
- Коммуникация и обслуживание. Необходимо учитывать ситуации потери запросов/данных.
- Согласованность данных. Некоторые компоненты могут быть несинхронизированы между собой. Например когда несколько сервисов обращаются к одному источнику данных.
- Дебаг. Сложно определить где конкретно вышла ошибка, если взаимодействовало несколько микросервисов. Точек отказа больше.

Если микросервисы независимы друг от друга, то как же они передают друг другу информацию? С монолитом все понятно - там все лежит в одном месте. С микросервисами все иначе. Предположим, у нас есть 2 микросервиса, которые находятся на разных серверах. В таком случае из первого сервиса во второй отправляется запрос, на который обратно приходит ответ. Делается это при помощи технологи HTTP.